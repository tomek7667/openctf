// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"openctfbackend/ent/contest"
	"openctfbackend/ent/contestrating"
	"openctfbackend/ent/place"
	"openctfbackend/ent/predicate"
	"openctfbackend/ent/team"
	"openctfbackend/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeContest       = "Contest"
	TypeContestRating = "ContestRating"
	TypePlace         = "Place"
	TypeTeam          = "Team"
	TypeUser          = "User"
)

// ContestMutation represents an operation that mutates the Contest nodes in the graph.
type ContestMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	description               *string
	rules                     *string
	prizes                    *string
	start                     *time.Time
	end                       *time.Time
	url                       *string
	ctftime_id                *int
	addctftime_id             *int
	assigned_weight_points    *int
	addassigned_weight_points *int
	clearedFields             map[string]struct{}
	organizers                *int
	clearedorganizers         bool
	places                    map[int]struct{}
	removedplaces             map[int]struct{}
	clearedplaces             bool
	done                      bool
	oldValue                  func(context.Context) (*Contest, error)
	predicates                []predicate.Contest
}

var _ ent.Mutation = (*ContestMutation)(nil)

// contestOption allows management of the mutation configuration using functional options.
type contestOption func(*ContestMutation)

// newContestMutation creates new mutation for the Contest entity.
func newContestMutation(c config, op Op, opts ...contestOption) *ContestMutation {
	m := &ContestMutation{
		config:        c,
		op:            op,
		typ:           TypeContest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContestID sets the ID field of the mutation.
func withContestID(id int) contestOption {
	return func(m *ContestMutation) {
		var (
			err   error
			once  sync.Once
			value *Contest
		)
		m.oldValue = func(ctx context.Context) (*Contest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContest sets the old Contest of the mutation.
func withContest(node *Contest) contestOption {
	return func(m *ContestMutation) {
		m.oldValue = func(context.Context) (*Contest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ContestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContestMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ContestMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ContestMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ContestMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[contest.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ContestMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[contest.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ContestMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, contest.FieldDescription)
}

// SetRules sets the "rules" field.
func (m *ContestMutation) SetRules(s string) {
	m.rules = &s
}

// Rules returns the value of the "rules" field in the mutation.
func (m *ContestMutation) Rules() (r string, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldRules(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// ClearRules clears the value of the "rules" field.
func (m *ContestMutation) ClearRules() {
	m.rules = nil
	m.clearedFields[contest.FieldRules] = struct{}{}
}

// RulesCleared returns if the "rules" field was cleared in this mutation.
func (m *ContestMutation) RulesCleared() bool {
	_, ok := m.clearedFields[contest.FieldRules]
	return ok
}

// ResetRules resets all changes to the "rules" field.
func (m *ContestMutation) ResetRules() {
	m.rules = nil
	delete(m.clearedFields, contest.FieldRules)
}

// SetPrizes sets the "prizes" field.
func (m *ContestMutation) SetPrizes(s string) {
	m.prizes = &s
}

// Prizes returns the value of the "prizes" field in the mutation.
func (m *ContestMutation) Prizes() (r string, exists bool) {
	v := m.prizes
	if v == nil {
		return
	}
	return *v, true
}

// OldPrizes returns the old "prizes" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldPrizes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrizes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrizes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrizes: %w", err)
	}
	return oldValue.Prizes, nil
}

// ClearPrizes clears the value of the "prizes" field.
func (m *ContestMutation) ClearPrizes() {
	m.prizes = nil
	m.clearedFields[contest.FieldPrizes] = struct{}{}
}

// PrizesCleared returns if the "prizes" field was cleared in this mutation.
func (m *ContestMutation) PrizesCleared() bool {
	_, ok := m.clearedFields[contest.FieldPrizes]
	return ok
}

// ResetPrizes resets all changes to the "prizes" field.
func (m *ContestMutation) ResetPrizes() {
	m.prizes = nil
	delete(m.clearedFields, contest.FieldPrizes)
}

// SetStart sets the "start" field.
func (m *ContestMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *ContestMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *ContestMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *ContestMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *ContestMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *ContestMutation) ResetEnd() {
	m.end = nil
}

// SetURL sets the "url" field.
func (m *ContestMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ContestMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ContestMutation) ClearURL() {
	m.url = nil
	m.clearedFields[contest.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ContestMutation) URLCleared() bool {
	_, ok := m.clearedFields[contest.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ContestMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, contest.FieldURL)
}

// SetCtftimeID sets the "ctftime_id" field.
func (m *ContestMutation) SetCtftimeID(i int) {
	m.ctftime_id = &i
	m.addctftime_id = nil
}

// CtftimeID returns the value of the "ctftime_id" field in the mutation.
func (m *ContestMutation) CtftimeID() (r int, exists bool) {
	v := m.ctftime_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCtftimeID returns the old "ctftime_id" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldCtftimeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCtftimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCtftimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCtftimeID: %w", err)
	}
	return oldValue.CtftimeID, nil
}

// AddCtftimeID adds i to the "ctftime_id" field.
func (m *ContestMutation) AddCtftimeID(i int) {
	if m.addctftime_id != nil {
		*m.addctftime_id += i
	} else {
		m.addctftime_id = &i
	}
}

// AddedCtftimeID returns the value that was added to the "ctftime_id" field in this mutation.
func (m *ContestMutation) AddedCtftimeID() (r int, exists bool) {
	v := m.addctftime_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCtftimeID clears the value of the "ctftime_id" field.
func (m *ContestMutation) ClearCtftimeID() {
	m.ctftime_id = nil
	m.addctftime_id = nil
	m.clearedFields[contest.FieldCtftimeID] = struct{}{}
}

// CtftimeIDCleared returns if the "ctftime_id" field was cleared in this mutation.
func (m *ContestMutation) CtftimeIDCleared() bool {
	_, ok := m.clearedFields[contest.FieldCtftimeID]
	return ok
}

// ResetCtftimeID resets all changes to the "ctftime_id" field.
func (m *ContestMutation) ResetCtftimeID() {
	m.ctftime_id = nil
	m.addctftime_id = nil
	delete(m.clearedFields, contest.FieldCtftimeID)
}

// SetAssignedWeightPoints sets the "assigned_weight_points" field.
func (m *ContestMutation) SetAssignedWeightPoints(i int) {
	m.assigned_weight_points = &i
	m.addassigned_weight_points = nil
}

// AssignedWeightPoints returns the value of the "assigned_weight_points" field in the mutation.
func (m *ContestMutation) AssignedWeightPoints() (r int, exists bool) {
	v := m.assigned_weight_points
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedWeightPoints returns the old "assigned_weight_points" field's value of the Contest entity.
// If the Contest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestMutation) OldAssignedWeightPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedWeightPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedWeightPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedWeightPoints: %w", err)
	}
	return oldValue.AssignedWeightPoints, nil
}

// AddAssignedWeightPoints adds i to the "assigned_weight_points" field.
func (m *ContestMutation) AddAssignedWeightPoints(i int) {
	if m.addassigned_weight_points != nil {
		*m.addassigned_weight_points += i
	} else {
		m.addassigned_weight_points = &i
	}
}

// AddedAssignedWeightPoints returns the value that was added to the "assigned_weight_points" field in this mutation.
func (m *ContestMutation) AddedAssignedWeightPoints() (r int, exists bool) {
	v := m.addassigned_weight_points
	if v == nil {
		return
	}
	return *v, true
}

// ResetAssignedWeightPoints resets all changes to the "assigned_weight_points" field.
func (m *ContestMutation) ResetAssignedWeightPoints() {
	m.assigned_weight_points = nil
	m.addassigned_weight_points = nil
}

// SetOrganizersID sets the "organizers" edge to the Team entity by id.
func (m *ContestMutation) SetOrganizersID(id int) {
	m.organizers = &id
}

// ClearOrganizers clears the "organizers" edge to the Team entity.
func (m *ContestMutation) ClearOrganizers() {
	m.clearedorganizers = true
}

// OrganizersCleared reports if the "organizers" edge to the Team entity was cleared.
func (m *ContestMutation) OrganizersCleared() bool {
	return m.clearedorganizers
}

// OrganizersID returns the "organizers" edge ID in the mutation.
func (m *ContestMutation) OrganizersID() (id int, exists bool) {
	if m.organizers != nil {
		return *m.organizers, true
	}
	return
}

// OrganizersIDs returns the "organizers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizersID instead. It exists only for internal usage by the builders.
func (m *ContestMutation) OrganizersIDs() (ids []int) {
	if id := m.organizers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganizers resets all changes to the "organizers" edge.
func (m *ContestMutation) ResetOrganizers() {
	m.organizers = nil
	m.clearedorganizers = false
}

// AddPlaceIDs adds the "places" edge to the Place entity by ids.
func (m *ContestMutation) AddPlaceIDs(ids ...int) {
	if m.places == nil {
		m.places = make(map[int]struct{})
	}
	for i := range ids {
		m.places[ids[i]] = struct{}{}
	}
}

// ClearPlaces clears the "places" edge to the Place entity.
func (m *ContestMutation) ClearPlaces() {
	m.clearedplaces = true
}

// PlacesCleared reports if the "places" edge to the Place entity was cleared.
func (m *ContestMutation) PlacesCleared() bool {
	return m.clearedplaces
}

// RemovePlaceIDs removes the "places" edge to the Place entity by IDs.
func (m *ContestMutation) RemovePlaceIDs(ids ...int) {
	if m.removedplaces == nil {
		m.removedplaces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.places, ids[i])
		m.removedplaces[ids[i]] = struct{}{}
	}
}

// RemovedPlaces returns the removed IDs of the "places" edge to the Place entity.
func (m *ContestMutation) RemovedPlacesIDs() (ids []int) {
	for id := range m.removedplaces {
		ids = append(ids, id)
	}
	return
}

// PlacesIDs returns the "places" edge IDs in the mutation.
func (m *ContestMutation) PlacesIDs() (ids []int) {
	for id := range m.places {
		ids = append(ids, id)
	}
	return
}

// ResetPlaces resets all changes to the "places" edge.
func (m *ContestMutation) ResetPlaces() {
	m.places = nil
	m.clearedplaces = false
	m.removedplaces = nil
}

// Where appends a list predicates to the ContestMutation builder.
func (m *ContestMutation) Where(ps ...predicate.Contest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contest).
func (m *ContestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContestMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, contest.FieldName)
	}
	if m.description != nil {
		fields = append(fields, contest.FieldDescription)
	}
	if m.rules != nil {
		fields = append(fields, contest.FieldRules)
	}
	if m.prizes != nil {
		fields = append(fields, contest.FieldPrizes)
	}
	if m.start != nil {
		fields = append(fields, contest.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, contest.FieldEnd)
	}
	if m.url != nil {
		fields = append(fields, contest.FieldURL)
	}
	if m.ctftime_id != nil {
		fields = append(fields, contest.FieldCtftimeID)
	}
	if m.assigned_weight_points != nil {
		fields = append(fields, contest.FieldAssignedWeightPoints)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contest.FieldName:
		return m.Name()
	case contest.FieldDescription:
		return m.Description()
	case contest.FieldRules:
		return m.Rules()
	case contest.FieldPrizes:
		return m.Prizes()
	case contest.FieldStart:
		return m.Start()
	case contest.FieldEnd:
		return m.End()
	case contest.FieldURL:
		return m.URL()
	case contest.FieldCtftimeID:
		return m.CtftimeID()
	case contest.FieldAssignedWeightPoints:
		return m.AssignedWeightPoints()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contest.FieldName:
		return m.OldName(ctx)
	case contest.FieldDescription:
		return m.OldDescription(ctx)
	case contest.FieldRules:
		return m.OldRules(ctx)
	case contest.FieldPrizes:
		return m.OldPrizes(ctx)
	case contest.FieldStart:
		return m.OldStart(ctx)
	case contest.FieldEnd:
		return m.OldEnd(ctx)
	case contest.FieldURL:
		return m.OldURL(ctx)
	case contest.FieldCtftimeID:
		return m.OldCtftimeID(ctx)
	case contest.FieldAssignedWeightPoints:
		return m.OldAssignedWeightPoints(ctx)
	}
	return nil, fmt.Errorf("unknown Contest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contest.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case contest.FieldRules:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	case contest.FieldPrizes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrizes(v)
		return nil
	case contest.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case contest.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case contest.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case contest.FieldCtftimeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCtftimeID(v)
		return nil
	case contest.FieldAssignedWeightPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedWeightPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Contest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContestMutation) AddedFields() []string {
	var fields []string
	if m.addctftime_id != nil {
		fields = append(fields, contest.FieldCtftimeID)
	}
	if m.addassigned_weight_points != nil {
		fields = append(fields, contest.FieldAssignedWeightPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contest.FieldCtftimeID:
		return m.AddedCtftimeID()
	case contest.FieldAssignedWeightPoints:
		return m.AddedAssignedWeightPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contest.FieldCtftimeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCtftimeID(v)
		return nil
	case contest.FieldAssignedWeightPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignedWeightPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Contest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contest.FieldDescription) {
		fields = append(fields, contest.FieldDescription)
	}
	if m.FieldCleared(contest.FieldRules) {
		fields = append(fields, contest.FieldRules)
	}
	if m.FieldCleared(contest.FieldPrizes) {
		fields = append(fields, contest.FieldPrizes)
	}
	if m.FieldCleared(contest.FieldURL) {
		fields = append(fields, contest.FieldURL)
	}
	if m.FieldCleared(contest.FieldCtftimeID) {
		fields = append(fields, contest.FieldCtftimeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContestMutation) ClearField(name string) error {
	switch name {
	case contest.FieldDescription:
		m.ClearDescription()
		return nil
	case contest.FieldRules:
		m.ClearRules()
		return nil
	case contest.FieldPrizes:
		m.ClearPrizes()
		return nil
	case contest.FieldURL:
		m.ClearURL()
		return nil
	case contest.FieldCtftimeID:
		m.ClearCtftimeID()
		return nil
	}
	return fmt.Errorf("unknown Contest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContestMutation) ResetField(name string) error {
	switch name {
	case contest.FieldName:
		m.ResetName()
		return nil
	case contest.FieldDescription:
		m.ResetDescription()
		return nil
	case contest.FieldRules:
		m.ResetRules()
		return nil
	case contest.FieldPrizes:
		m.ResetPrizes()
		return nil
	case contest.FieldStart:
		m.ResetStart()
		return nil
	case contest.FieldEnd:
		m.ResetEnd()
		return nil
	case contest.FieldURL:
		m.ResetURL()
		return nil
	case contest.FieldCtftimeID:
		m.ResetCtftimeID()
		return nil
	case contest.FieldAssignedWeightPoints:
		m.ResetAssignedWeightPoints()
		return nil
	}
	return fmt.Errorf("unknown Contest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organizers != nil {
		edges = append(edges, contest.EdgeOrganizers)
	}
	if m.places != nil {
		edges = append(edges, contest.EdgePlaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contest.EdgeOrganizers:
		if id := m.organizers; id != nil {
			return []ent.Value{*id}
		}
	case contest.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.places))
		for id := range m.places {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedplaces != nil {
		edges = append(edges, contest.EdgePlaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contest.EdgePlaces:
		ids := make([]ent.Value, 0, len(m.removedplaces))
		for id := range m.removedplaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganizers {
		edges = append(edges, contest.EdgeOrganizers)
	}
	if m.clearedplaces {
		edges = append(edges, contest.EdgePlaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContestMutation) EdgeCleared(name string) bool {
	switch name {
	case contest.EdgeOrganizers:
		return m.clearedorganizers
	case contest.EdgePlaces:
		return m.clearedplaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContestMutation) ClearEdge(name string) error {
	switch name {
	case contest.EdgeOrganizers:
		m.ClearOrganizers()
		return nil
	}
	return fmt.Errorf("unknown Contest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContestMutation) ResetEdge(name string) error {
	switch name {
	case contest.EdgeOrganizers:
		m.ResetOrganizers()
		return nil
	case contest.EdgePlaces:
		m.ResetPlaces()
		return nil
	}
	return fmt.Errorf("unknown Contest edge %s", name)
}

// ContestRatingMutation represents an operation that mutates the ContestRating nodes in the graph.
type ContestRatingMutation struct {
	config
	op             Op
	typ            string
	id             *int
	rating         *int
	addrating      *int
	relevant       *bool
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	contest        *int
	clearedcontest bool
	done           bool
	oldValue       func(context.Context) (*ContestRating, error)
	predicates     []predicate.ContestRating
}

var _ ent.Mutation = (*ContestRatingMutation)(nil)

// contestratingOption allows management of the mutation configuration using functional options.
type contestratingOption func(*ContestRatingMutation)

// newContestRatingMutation creates new mutation for the ContestRating entity.
func newContestRatingMutation(c config, op Op, opts ...contestratingOption) *ContestRatingMutation {
	m := &ContestRatingMutation{
		config:        c,
		op:            op,
		typ:           TypeContestRating,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContestRatingID sets the ID field of the mutation.
func withContestRatingID(id int) contestratingOption {
	return func(m *ContestRatingMutation) {
		var (
			err   error
			once  sync.Once
			value *ContestRating
		)
		m.oldValue = func(ctx context.Context) (*ContestRating, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContestRating.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContestRating sets the old ContestRating of the mutation.
func withContestRating(node *ContestRating) contestratingOption {
	return func(m *ContestRatingMutation) {
		m.oldValue = func(context.Context) (*ContestRating, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContestRatingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContestRatingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContestRatingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContestRatingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContestRating.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRating sets the "rating" field.
func (m *ContestRatingMutation) SetRating(i int) {
	m.rating = &i
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *ContestRatingMutation) Rating() (r int, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the ContestRating entity.
// If the ContestRating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestRatingMutation) OldRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds i to the "rating" field.
func (m *ContestRatingMutation) AddRating(i int) {
	if m.addrating != nil {
		*m.addrating += i
	} else {
		m.addrating = &i
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *ContestRatingMutation) AddedRating() (r int, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *ContestRatingMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetRelevant sets the "relevant" field.
func (m *ContestRatingMutation) SetRelevant(b bool) {
	m.relevant = &b
}

// Relevant returns the value of the "relevant" field in the mutation.
func (m *ContestRatingMutation) Relevant() (r bool, exists bool) {
	v := m.relevant
	if v == nil {
		return
	}
	return *v, true
}

// OldRelevant returns the old "relevant" field's value of the ContestRating entity.
// If the ContestRating object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContestRatingMutation) OldRelevant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelevant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelevant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelevant: %w", err)
	}
	return oldValue.Relevant, nil
}

// ResetRelevant resets all changes to the "relevant" field.
func (m *ContestRatingMutation) ResetRelevant() {
	m.relevant = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ContestRatingMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ContestRatingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ContestRatingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ContestRatingMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ContestRatingMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ContestRatingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetContestID sets the "contest" edge to the Contest entity by id.
func (m *ContestRatingMutation) SetContestID(id int) {
	m.contest = &id
}

// ClearContest clears the "contest" edge to the Contest entity.
func (m *ContestRatingMutation) ClearContest() {
	m.clearedcontest = true
}

// ContestCleared reports if the "contest" edge to the Contest entity was cleared.
func (m *ContestRatingMutation) ContestCleared() bool {
	return m.clearedcontest
}

// ContestID returns the "contest" edge ID in the mutation.
func (m *ContestRatingMutation) ContestID() (id int, exists bool) {
	if m.contest != nil {
		return *m.contest, true
	}
	return
}

// ContestIDs returns the "contest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContestID instead. It exists only for internal usage by the builders.
func (m *ContestRatingMutation) ContestIDs() (ids []int) {
	if id := m.contest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContest resets all changes to the "contest" edge.
func (m *ContestRatingMutation) ResetContest() {
	m.contest = nil
	m.clearedcontest = false
}

// Where appends a list predicates to the ContestRatingMutation builder.
func (m *ContestRatingMutation) Where(ps ...predicate.ContestRating) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContestRatingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContestRatingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContestRating, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContestRatingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContestRatingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContestRating).
func (m *ContestRatingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContestRatingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.rating != nil {
		fields = append(fields, contestrating.FieldRating)
	}
	if m.relevant != nil {
		fields = append(fields, contestrating.FieldRelevant)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContestRatingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contestrating.FieldRating:
		return m.Rating()
	case contestrating.FieldRelevant:
		return m.Relevant()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContestRatingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contestrating.FieldRating:
		return m.OldRating(ctx)
	case contestrating.FieldRelevant:
		return m.OldRelevant(ctx)
	}
	return nil, fmt.Errorf("unknown ContestRating field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestRatingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contestrating.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case contestrating.FieldRelevant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelevant(v)
		return nil
	}
	return fmt.Errorf("unknown ContestRating field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContestRatingMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, contestrating.FieldRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContestRatingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contestrating.FieldRating:
		return m.AddedRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContestRatingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contestrating.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	}
	return fmt.Errorf("unknown ContestRating numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContestRatingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContestRatingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContestRatingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ContestRating nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContestRatingMutation) ResetField(name string) error {
	switch name {
	case contestrating.FieldRating:
		m.ResetRating()
		return nil
	case contestrating.FieldRelevant:
		m.ResetRelevant()
		return nil
	}
	return fmt.Errorf("unknown ContestRating field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContestRatingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, contestrating.EdgeUser)
	}
	if m.contest != nil {
		edges = append(edges, contestrating.EdgeContest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContestRatingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contestrating.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case contestrating.EdgeContest:
		if id := m.contest; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContestRatingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContestRatingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContestRatingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, contestrating.EdgeUser)
	}
	if m.clearedcontest {
		edges = append(edges, contestrating.EdgeContest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContestRatingMutation) EdgeCleared(name string) bool {
	switch name {
	case contestrating.EdgeUser:
		return m.cleareduser
	case contestrating.EdgeContest:
		return m.clearedcontest
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContestRatingMutation) ClearEdge(name string) error {
	switch name {
	case contestrating.EdgeUser:
		m.ClearUser()
		return nil
	case contestrating.EdgeContest:
		m.ClearContest()
		return nil
	}
	return fmt.Errorf("unknown ContestRating unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContestRatingMutation) ResetEdge(name string) error {
	switch name {
	case contestrating.EdgeUser:
		m.ResetUser()
		return nil
	case contestrating.EdgeContest:
		m.ResetContest()
		return nil
	}
	return fmt.Errorf("unknown ContestRating edge %s", name)
}

// PlaceMutation represents an operation that mutates the Place nodes in the graph.
type PlaceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	team_name                 *string
	place                     *int
	addplace                  *int
	ctftime_team_id           *int
	addctftime_team_id        *int
	contest_points            *float64
	addcontest_points         *float64
	openctf_points            *float64
	addopenctf_points         *float64
	associated_contest_id     *int
	addassociated_contest_id  *int
	assigned_weight_points    *int
	addassigned_weight_points *int
	clearedFields             map[string]struct{}
	associated_team           *int
	clearedassociated_team    bool
	done                      bool
	oldValue                  func(context.Context) (*Place, error)
	predicates                []predicate.Place
}

var _ ent.Mutation = (*PlaceMutation)(nil)

// placeOption allows management of the mutation configuration using functional options.
type placeOption func(*PlaceMutation)

// newPlaceMutation creates new mutation for the Place entity.
func newPlaceMutation(c config, op Op, opts ...placeOption) *PlaceMutation {
	m := &PlaceMutation{
		config:        c,
		op:            op,
		typ:           TypePlace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaceID sets the ID field of the mutation.
func withPlaceID(id int) placeOption {
	return func(m *PlaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Place
		)
		m.oldValue = func(ctx context.Context) (*Place, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Place.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlace sets the old Place of the mutation.
func withPlace(node *Place) placeOption {
	return func(m *PlaceMutation) {
		m.oldValue = func(context.Context) (*Place, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Place.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeamName sets the "team_name" field.
func (m *PlaceMutation) SetTeamName(s string) {
	m.team_name = &s
}

// TeamName returns the value of the "team_name" field in the mutation.
func (m *PlaceMutation) TeamName() (r string, exists bool) {
	v := m.team_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamName returns the old "team_name" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldTeamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamName: %w", err)
	}
	return oldValue.TeamName, nil
}

// ResetTeamName resets all changes to the "team_name" field.
func (m *PlaceMutation) ResetTeamName() {
	m.team_name = nil
}

// SetPlace sets the "place" field.
func (m *PlaceMutation) SetPlace(i int) {
	m.place = &i
	m.addplace = nil
}

// Place returns the value of the "place" field in the mutation.
func (m *PlaceMutation) Place() (r int, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldPlace(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// AddPlace adds i to the "place" field.
func (m *PlaceMutation) AddPlace(i int) {
	if m.addplace != nil {
		*m.addplace += i
	} else {
		m.addplace = &i
	}
}

// AddedPlace returns the value that was added to the "place" field in this mutation.
func (m *PlaceMutation) AddedPlace() (r int, exists bool) {
	v := m.addplace
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlace resets all changes to the "place" field.
func (m *PlaceMutation) ResetPlace() {
	m.place = nil
	m.addplace = nil
}

// SetCtftimeTeamID sets the "ctftime_team_id" field.
func (m *PlaceMutation) SetCtftimeTeamID(i int) {
	m.ctftime_team_id = &i
	m.addctftime_team_id = nil
}

// CtftimeTeamID returns the value of the "ctftime_team_id" field in the mutation.
func (m *PlaceMutation) CtftimeTeamID() (r int, exists bool) {
	v := m.ctftime_team_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCtftimeTeamID returns the old "ctftime_team_id" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldCtftimeTeamID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCtftimeTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCtftimeTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCtftimeTeamID: %w", err)
	}
	return oldValue.CtftimeTeamID, nil
}

// AddCtftimeTeamID adds i to the "ctftime_team_id" field.
func (m *PlaceMutation) AddCtftimeTeamID(i int) {
	if m.addctftime_team_id != nil {
		*m.addctftime_team_id += i
	} else {
		m.addctftime_team_id = &i
	}
}

// AddedCtftimeTeamID returns the value that was added to the "ctftime_team_id" field in this mutation.
func (m *PlaceMutation) AddedCtftimeTeamID() (r int, exists bool) {
	v := m.addctftime_team_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCtftimeTeamID clears the value of the "ctftime_team_id" field.
func (m *PlaceMutation) ClearCtftimeTeamID() {
	m.ctftime_team_id = nil
	m.addctftime_team_id = nil
	m.clearedFields[place.FieldCtftimeTeamID] = struct{}{}
}

// CtftimeTeamIDCleared returns if the "ctftime_team_id" field was cleared in this mutation.
func (m *PlaceMutation) CtftimeTeamIDCleared() bool {
	_, ok := m.clearedFields[place.FieldCtftimeTeamID]
	return ok
}

// ResetCtftimeTeamID resets all changes to the "ctftime_team_id" field.
func (m *PlaceMutation) ResetCtftimeTeamID() {
	m.ctftime_team_id = nil
	m.addctftime_team_id = nil
	delete(m.clearedFields, place.FieldCtftimeTeamID)
}

// SetContestPoints sets the "contest_points" field.
func (m *PlaceMutation) SetContestPoints(f float64) {
	m.contest_points = &f
	m.addcontest_points = nil
}

// ContestPoints returns the value of the "contest_points" field in the mutation.
func (m *PlaceMutation) ContestPoints() (r float64, exists bool) {
	v := m.contest_points
	if v == nil {
		return
	}
	return *v, true
}

// OldContestPoints returns the old "contest_points" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldContestPoints(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContestPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContestPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContestPoints: %w", err)
	}
	return oldValue.ContestPoints, nil
}

// AddContestPoints adds f to the "contest_points" field.
func (m *PlaceMutation) AddContestPoints(f float64) {
	if m.addcontest_points != nil {
		*m.addcontest_points += f
	} else {
		m.addcontest_points = &f
	}
}

// AddedContestPoints returns the value that was added to the "contest_points" field in this mutation.
func (m *PlaceMutation) AddedContestPoints() (r float64, exists bool) {
	v := m.addcontest_points
	if v == nil {
		return
	}
	return *v, true
}

// ClearContestPoints clears the value of the "contest_points" field.
func (m *PlaceMutation) ClearContestPoints() {
	m.contest_points = nil
	m.addcontest_points = nil
	m.clearedFields[place.FieldContestPoints] = struct{}{}
}

// ContestPointsCleared returns if the "contest_points" field was cleared in this mutation.
func (m *PlaceMutation) ContestPointsCleared() bool {
	_, ok := m.clearedFields[place.FieldContestPoints]
	return ok
}

// ResetContestPoints resets all changes to the "contest_points" field.
func (m *PlaceMutation) ResetContestPoints() {
	m.contest_points = nil
	m.addcontest_points = nil
	delete(m.clearedFields, place.FieldContestPoints)
}

// SetOpenctfPoints sets the "openctf_points" field.
func (m *PlaceMutation) SetOpenctfPoints(f float64) {
	m.openctf_points = &f
	m.addopenctf_points = nil
}

// OpenctfPoints returns the value of the "openctf_points" field in the mutation.
func (m *PlaceMutation) OpenctfPoints() (r float64, exists bool) {
	v := m.openctf_points
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenctfPoints returns the old "openctf_points" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldOpenctfPoints(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenctfPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenctfPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenctfPoints: %w", err)
	}
	return oldValue.OpenctfPoints, nil
}

// AddOpenctfPoints adds f to the "openctf_points" field.
func (m *PlaceMutation) AddOpenctfPoints(f float64) {
	if m.addopenctf_points != nil {
		*m.addopenctf_points += f
	} else {
		m.addopenctf_points = &f
	}
}

// AddedOpenctfPoints returns the value that was added to the "openctf_points" field in this mutation.
func (m *PlaceMutation) AddedOpenctfPoints() (r float64, exists bool) {
	v := m.addopenctf_points
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpenctfPoints clears the value of the "openctf_points" field.
func (m *PlaceMutation) ClearOpenctfPoints() {
	m.openctf_points = nil
	m.addopenctf_points = nil
	m.clearedFields[place.FieldOpenctfPoints] = struct{}{}
}

// OpenctfPointsCleared returns if the "openctf_points" field was cleared in this mutation.
func (m *PlaceMutation) OpenctfPointsCleared() bool {
	_, ok := m.clearedFields[place.FieldOpenctfPoints]
	return ok
}

// ResetOpenctfPoints resets all changes to the "openctf_points" field.
func (m *PlaceMutation) ResetOpenctfPoints() {
	m.openctf_points = nil
	m.addopenctf_points = nil
	delete(m.clearedFields, place.FieldOpenctfPoints)
}

// SetAssociatedContestID sets the "associated_contest_id" field.
func (m *PlaceMutation) SetAssociatedContestID(i int) {
	m.associated_contest_id = &i
	m.addassociated_contest_id = nil
}

// AssociatedContestID returns the value of the "associated_contest_id" field in the mutation.
func (m *PlaceMutation) AssociatedContestID() (r int, exists bool) {
	v := m.associated_contest_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssociatedContestID returns the old "associated_contest_id" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldAssociatedContestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssociatedContestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssociatedContestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssociatedContestID: %w", err)
	}
	return oldValue.AssociatedContestID, nil
}

// AddAssociatedContestID adds i to the "associated_contest_id" field.
func (m *PlaceMutation) AddAssociatedContestID(i int) {
	if m.addassociated_contest_id != nil {
		*m.addassociated_contest_id += i
	} else {
		m.addassociated_contest_id = &i
	}
}

// AddedAssociatedContestID returns the value that was added to the "associated_contest_id" field in this mutation.
func (m *PlaceMutation) AddedAssociatedContestID() (r int, exists bool) {
	v := m.addassociated_contest_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAssociatedContestID resets all changes to the "associated_contest_id" field.
func (m *PlaceMutation) ResetAssociatedContestID() {
	m.associated_contest_id = nil
	m.addassociated_contest_id = nil
}

// SetAssignedWeightPoints sets the "assigned_weight_points" field.
func (m *PlaceMutation) SetAssignedWeightPoints(i int) {
	m.assigned_weight_points = &i
	m.addassigned_weight_points = nil
}

// AssignedWeightPoints returns the value of the "assigned_weight_points" field in the mutation.
func (m *PlaceMutation) AssignedWeightPoints() (r int, exists bool) {
	v := m.assigned_weight_points
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedWeightPoints returns the old "assigned_weight_points" field's value of the Place entity.
// If the Place object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaceMutation) OldAssignedWeightPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedWeightPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedWeightPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedWeightPoints: %w", err)
	}
	return oldValue.AssignedWeightPoints, nil
}

// AddAssignedWeightPoints adds i to the "assigned_weight_points" field.
func (m *PlaceMutation) AddAssignedWeightPoints(i int) {
	if m.addassigned_weight_points != nil {
		*m.addassigned_weight_points += i
	} else {
		m.addassigned_weight_points = &i
	}
}

// AddedAssignedWeightPoints returns the value that was added to the "assigned_weight_points" field in this mutation.
func (m *PlaceMutation) AddedAssignedWeightPoints() (r int, exists bool) {
	v := m.addassigned_weight_points
	if v == nil {
		return
	}
	return *v, true
}

// ResetAssignedWeightPoints resets all changes to the "assigned_weight_points" field.
func (m *PlaceMutation) ResetAssignedWeightPoints() {
	m.assigned_weight_points = nil
	m.addassigned_weight_points = nil
}

// SetAssociatedTeamID sets the "associated_team" edge to the Team entity by id.
func (m *PlaceMutation) SetAssociatedTeamID(id int) {
	m.associated_team = &id
}

// ClearAssociatedTeam clears the "associated_team" edge to the Team entity.
func (m *PlaceMutation) ClearAssociatedTeam() {
	m.clearedassociated_team = true
}

// AssociatedTeamCleared reports if the "associated_team" edge to the Team entity was cleared.
func (m *PlaceMutation) AssociatedTeamCleared() bool {
	return m.clearedassociated_team
}

// AssociatedTeamID returns the "associated_team" edge ID in the mutation.
func (m *PlaceMutation) AssociatedTeamID() (id int, exists bool) {
	if m.associated_team != nil {
		return *m.associated_team, true
	}
	return
}

// AssociatedTeamIDs returns the "associated_team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssociatedTeamID instead. It exists only for internal usage by the builders.
func (m *PlaceMutation) AssociatedTeamIDs() (ids []int) {
	if id := m.associated_team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssociatedTeam resets all changes to the "associated_team" edge.
func (m *PlaceMutation) ResetAssociatedTeam() {
	m.associated_team = nil
	m.clearedassociated_team = false
}

// Where appends a list predicates to the PlaceMutation builder.
func (m *PlaceMutation) Where(ps ...predicate.Place) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Place, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Place).
func (m *PlaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.team_name != nil {
		fields = append(fields, place.FieldTeamName)
	}
	if m.place != nil {
		fields = append(fields, place.FieldPlace)
	}
	if m.ctftime_team_id != nil {
		fields = append(fields, place.FieldCtftimeTeamID)
	}
	if m.contest_points != nil {
		fields = append(fields, place.FieldContestPoints)
	}
	if m.openctf_points != nil {
		fields = append(fields, place.FieldOpenctfPoints)
	}
	if m.associated_contest_id != nil {
		fields = append(fields, place.FieldAssociatedContestID)
	}
	if m.assigned_weight_points != nil {
		fields = append(fields, place.FieldAssignedWeightPoints)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case place.FieldTeamName:
		return m.TeamName()
	case place.FieldPlace:
		return m.Place()
	case place.FieldCtftimeTeamID:
		return m.CtftimeTeamID()
	case place.FieldContestPoints:
		return m.ContestPoints()
	case place.FieldOpenctfPoints:
		return m.OpenctfPoints()
	case place.FieldAssociatedContestID:
		return m.AssociatedContestID()
	case place.FieldAssignedWeightPoints:
		return m.AssignedWeightPoints()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case place.FieldTeamName:
		return m.OldTeamName(ctx)
	case place.FieldPlace:
		return m.OldPlace(ctx)
	case place.FieldCtftimeTeamID:
		return m.OldCtftimeTeamID(ctx)
	case place.FieldContestPoints:
		return m.OldContestPoints(ctx)
	case place.FieldOpenctfPoints:
		return m.OldOpenctfPoints(ctx)
	case place.FieldAssociatedContestID:
		return m.OldAssociatedContestID(ctx)
	case place.FieldAssignedWeightPoints:
		return m.OldAssignedWeightPoints(ctx)
	}
	return nil, fmt.Errorf("unknown Place field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case place.FieldTeamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamName(v)
		return nil
	case place.FieldPlace:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case place.FieldCtftimeTeamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCtftimeTeamID(v)
		return nil
	case place.FieldContestPoints:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContestPoints(v)
		return nil
	case place.FieldOpenctfPoints:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenctfPoints(v)
		return nil
	case place.FieldAssociatedContestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssociatedContestID(v)
		return nil
	case place.FieldAssignedWeightPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedWeightPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaceMutation) AddedFields() []string {
	var fields []string
	if m.addplace != nil {
		fields = append(fields, place.FieldPlace)
	}
	if m.addctftime_team_id != nil {
		fields = append(fields, place.FieldCtftimeTeamID)
	}
	if m.addcontest_points != nil {
		fields = append(fields, place.FieldContestPoints)
	}
	if m.addopenctf_points != nil {
		fields = append(fields, place.FieldOpenctfPoints)
	}
	if m.addassociated_contest_id != nil {
		fields = append(fields, place.FieldAssociatedContestID)
	}
	if m.addassigned_weight_points != nil {
		fields = append(fields, place.FieldAssignedWeightPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case place.FieldPlace:
		return m.AddedPlace()
	case place.FieldCtftimeTeamID:
		return m.AddedCtftimeTeamID()
	case place.FieldContestPoints:
		return m.AddedContestPoints()
	case place.FieldOpenctfPoints:
		return m.AddedOpenctfPoints()
	case place.FieldAssociatedContestID:
		return m.AddedAssociatedContestID()
	case place.FieldAssignedWeightPoints:
		return m.AddedAssignedWeightPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case place.FieldPlace:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlace(v)
		return nil
	case place.FieldCtftimeTeamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCtftimeTeamID(v)
		return nil
	case place.FieldContestPoints:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContestPoints(v)
		return nil
	case place.FieldOpenctfPoints:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpenctfPoints(v)
		return nil
	case place.FieldAssociatedContestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssociatedContestID(v)
		return nil
	case place.FieldAssignedWeightPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignedWeightPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Place numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(place.FieldCtftimeTeamID) {
		fields = append(fields, place.FieldCtftimeTeamID)
	}
	if m.FieldCleared(place.FieldContestPoints) {
		fields = append(fields, place.FieldContestPoints)
	}
	if m.FieldCleared(place.FieldOpenctfPoints) {
		fields = append(fields, place.FieldOpenctfPoints)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaceMutation) ClearField(name string) error {
	switch name {
	case place.FieldCtftimeTeamID:
		m.ClearCtftimeTeamID()
		return nil
	case place.FieldContestPoints:
		m.ClearContestPoints()
		return nil
	case place.FieldOpenctfPoints:
		m.ClearOpenctfPoints()
		return nil
	}
	return fmt.Errorf("unknown Place nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaceMutation) ResetField(name string) error {
	switch name {
	case place.FieldTeamName:
		m.ResetTeamName()
		return nil
	case place.FieldPlace:
		m.ResetPlace()
		return nil
	case place.FieldCtftimeTeamID:
		m.ResetCtftimeTeamID()
		return nil
	case place.FieldContestPoints:
		m.ResetContestPoints()
		return nil
	case place.FieldOpenctfPoints:
		m.ResetOpenctfPoints()
		return nil
	case place.FieldAssociatedContestID:
		m.ResetAssociatedContestID()
		return nil
	case place.FieldAssignedWeightPoints:
		m.ResetAssignedWeightPoints()
		return nil
	}
	return fmt.Errorf("unknown Place field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.associated_team != nil {
		edges = append(edges, place.EdgeAssociatedTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case place.EdgeAssociatedTeam:
		if id := m.associated_team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedassociated_team {
		edges = append(edges, place.EdgeAssociatedTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaceMutation) EdgeCleared(name string) bool {
	switch name {
	case place.EdgeAssociatedTeam:
		return m.clearedassociated_team
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaceMutation) ClearEdge(name string) error {
	switch name {
	case place.EdgeAssociatedTeam:
		m.ClearAssociatedTeam()
		return nil
	}
	return fmt.Errorf("unknown Place unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaceMutation) ResetEdge(name string) error {
	switch name {
	case place.EdgeAssociatedTeam:
		m.ResetAssociatedTeam()
		return nil
	}
	return fmt.Errorf("unknown Place edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	description         *string
	ctftime_id          *int
	addctftime_id       *int
	ctftime_verified_at *time.Time
	logo                *[]byte
	verified_at         *time.Time
	clearedFields       map[string]struct{}
	captain             *int
	clearedcaptain      bool
	verified_by         *int
	clearedverified_by  bool
	members             map[int]struct{}
	removedmembers      map[int]struct{}
	clearedmembers      bool
	done                bool
	oldValue            func(context.Context) (*Team, error)
	predicates          []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TeamMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TeamMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TeamMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[team.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TeamMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[team.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TeamMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, team.FieldDescription)
}

// SetCtftimeID sets the "ctftime_id" field.
func (m *TeamMutation) SetCtftimeID(i int) {
	m.ctftime_id = &i
	m.addctftime_id = nil
}

// CtftimeID returns the value of the "ctftime_id" field in the mutation.
func (m *TeamMutation) CtftimeID() (r int, exists bool) {
	v := m.ctftime_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCtftimeID returns the old "ctftime_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCtftimeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCtftimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCtftimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCtftimeID: %w", err)
	}
	return oldValue.CtftimeID, nil
}

// AddCtftimeID adds i to the "ctftime_id" field.
func (m *TeamMutation) AddCtftimeID(i int) {
	if m.addctftime_id != nil {
		*m.addctftime_id += i
	} else {
		m.addctftime_id = &i
	}
}

// AddedCtftimeID returns the value that was added to the "ctftime_id" field in this mutation.
func (m *TeamMutation) AddedCtftimeID() (r int, exists bool) {
	v := m.addctftime_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCtftimeID clears the value of the "ctftime_id" field.
func (m *TeamMutation) ClearCtftimeID() {
	m.ctftime_id = nil
	m.addctftime_id = nil
	m.clearedFields[team.FieldCtftimeID] = struct{}{}
}

// CtftimeIDCleared returns if the "ctftime_id" field was cleared in this mutation.
func (m *TeamMutation) CtftimeIDCleared() bool {
	_, ok := m.clearedFields[team.FieldCtftimeID]
	return ok
}

// ResetCtftimeID resets all changes to the "ctftime_id" field.
func (m *TeamMutation) ResetCtftimeID() {
	m.ctftime_id = nil
	m.addctftime_id = nil
	delete(m.clearedFields, team.FieldCtftimeID)
}

// SetCtftimeVerifiedAt sets the "ctftime_verified_at" field.
func (m *TeamMutation) SetCtftimeVerifiedAt(t time.Time) {
	m.ctftime_verified_at = &t
}

// CtftimeVerifiedAt returns the value of the "ctftime_verified_at" field in the mutation.
func (m *TeamMutation) CtftimeVerifiedAt() (r time.Time, exists bool) {
	v := m.ctftime_verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCtftimeVerifiedAt returns the old "ctftime_verified_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCtftimeVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCtftimeVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCtftimeVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCtftimeVerifiedAt: %w", err)
	}
	return oldValue.CtftimeVerifiedAt, nil
}

// ClearCtftimeVerifiedAt clears the value of the "ctftime_verified_at" field.
func (m *TeamMutation) ClearCtftimeVerifiedAt() {
	m.ctftime_verified_at = nil
	m.clearedFields[team.FieldCtftimeVerifiedAt] = struct{}{}
}

// CtftimeVerifiedAtCleared returns if the "ctftime_verified_at" field was cleared in this mutation.
func (m *TeamMutation) CtftimeVerifiedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldCtftimeVerifiedAt]
	return ok
}

// ResetCtftimeVerifiedAt resets all changes to the "ctftime_verified_at" field.
func (m *TeamMutation) ResetCtftimeVerifiedAt() {
	m.ctftime_verified_at = nil
	delete(m.clearedFields, team.FieldCtftimeVerifiedAt)
}

// SetLogo sets the "logo" field.
func (m *TeamMutation) SetLogo(b []byte) {
	m.logo = &b
}

// Logo returns the value of the "logo" field in the mutation.
func (m *TeamMutation) Logo() (r []byte, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldLogo(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *TeamMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[team.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *TeamMutation) LogoCleared() bool {
	_, ok := m.clearedFields[team.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *TeamMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, team.FieldLogo)
}

// SetVerifiedAt sets the "verified_at" field.
func (m *TeamMutation) SetVerifiedAt(t time.Time) {
	m.verified_at = &t
}

// VerifiedAt returns the value of the "verified_at" field in the mutation.
func (m *TeamMutation) VerifiedAt() (r time.Time, exists bool) {
	v := m.verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedAt returns the old "verified_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedAt: %w", err)
	}
	return oldValue.VerifiedAt, nil
}

// ClearVerifiedAt clears the value of the "verified_at" field.
func (m *TeamMutation) ClearVerifiedAt() {
	m.verified_at = nil
	m.clearedFields[team.FieldVerifiedAt] = struct{}{}
}

// VerifiedAtCleared returns if the "verified_at" field was cleared in this mutation.
func (m *TeamMutation) VerifiedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldVerifiedAt]
	return ok
}

// ResetVerifiedAt resets all changes to the "verified_at" field.
func (m *TeamMutation) ResetVerifiedAt() {
	m.verified_at = nil
	delete(m.clearedFields, team.FieldVerifiedAt)
}

// SetCaptainID sets the "captain" edge to the User entity by id.
func (m *TeamMutation) SetCaptainID(id int) {
	m.captain = &id
}

// ClearCaptain clears the "captain" edge to the User entity.
func (m *TeamMutation) ClearCaptain() {
	m.clearedcaptain = true
}

// CaptainCleared reports if the "captain" edge to the User entity was cleared.
func (m *TeamMutation) CaptainCleared() bool {
	return m.clearedcaptain
}

// CaptainID returns the "captain" edge ID in the mutation.
func (m *TeamMutation) CaptainID() (id int, exists bool) {
	if m.captain != nil {
		return *m.captain, true
	}
	return
}

// CaptainIDs returns the "captain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CaptainID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) CaptainIDs() (ids []int) {
	if id := m.captain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCaptain resets all changes to the "captain" edge.
func (m *TeamMutation) ResetCaptain() {
	m.captain = nil
	m.clearedcaptain = false
}

// SetVerifiedByID sets the "verified_by" edge to the User entity by id.
func (m *TeamMutation) SetVerifiedByID(id int) {
	m.verified_by = &id
}

// ClearVerifiedBy clears the "verified_by" edge to the User entity.
func (m *TeamMutation) ClearVerifiedBy() {
	m.clearedverified_by = true
}

// VerifiedByCleared reports if the "verified_by" edge to the User entity was cleared.
func (m *TeamMutation) VerifiedByCleared() bool {
	return m.clearedverified_by
}

// VerifiedByID returns the "verified_by" edge ID in the mutation.
func (m *TeamMutation) VerifiedByID() (id int, exists bool) {
	if m.verified_by != nil {
		return *m.verified_by, true
	}
	return
}

// VerifiedByIDs returns the "verified_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VerifiedByID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) VerifiedByIDs() (ids []int) {
	if id := m.verified_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVerifiedBy resets all changes to the "verified_by" edge.
func (m *TeamMutation) ResetVerifiedBy() {
	m.verified_by = nil
	m.clearedverified_by = false
}

// AddMemberIDs adds the "members" edge to the User entity by ids.
func (m *TeamMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the User entity.
func (m *TeamMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the User entity was cleared.
func (m *TeamMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the User entity by IDs.
func (m *TeamMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the User entity.
func (m *TeamMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *TeamMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *TeamMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.description != nil {
		fields = append(fields, team.FieldDescription)
	}
	if m.ctftime_id != nil {
		fields = append(fields, team.FieldCtftimeID)
	}
	if m.ctftime_verified_at != nil {
		fields = append(fields, team.FieldCtftimeVerifiedAt)
	}
	if m.logo != nil {
		fields = append(fields, team.FieldLogo)
	}
	if m.verified_at != nil {
		fields = append(fields, team.FieldVerifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldName:
		return m.Name()
	case team.FieldDescription:
		return m.Description()
	case team.FieldCtftimeID:
		return m.CtftimeID()
	case team.FieldCtftimeVerifiedAt:
		return m.CtftimeVerifiedAt()
	case team.FieldLogo:
		return m.Logo()
	case team.FieldVerifiedAt:
		return m.VerifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldDescription:
		return m.OldDescription(ctx)
	case team.FieldCtftimeID:
		return m.OldCtftimeID(ctx)
	case team.FieldCtftimeVerifiedAt:
		return m.OldCtftimeVerifiedAt(ctx)
	case team.FieldLogo:
		return m.OldLogo(ctx)
	case team.FieldVerifiedAt:
		return m.OldVerifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case team.FieldCtftimeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCtftimeID(v)
		return nil
	case team.FieldCtftimeVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCtftimeVerifiedAt(v)
		return nil
	case team.FieldLogo:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case team.FieldVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addctftime_id != nil {
		fields = append(fields, team.FieldCtftimeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldCtftimeID:
		return m.AddedCtftimeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldCtftimeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCtftimeID(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldDescription) {
		fields = append(fields, team.FieldDescription)
	}
	if m.FieldCleared(team.FieldCtftimeID) {
		fields = append(fields, team.FieldCtftimeID)
	}
	if m.FieldCleared(team.FieldCtftimeVerifiedAt) {
		fields = append(fields, team.FieldCtftimeVerifiedAt)
	}
	if m.FieldCleared(team.FieldLogo) {
		fields = append(fields, team.FieldLogo)
	}
	if m.FieldCleared(team.FieldVerifiedAt) {
		fields = append(fields, team.FieldVerifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldDescription:
		m.ClearDescription()
		return nil
	case team.FieldCtftimeID:
		m.ClearCtftimeID()
		return nil
	case team.FieldCtftimeVerifiedAt:
		m.ClearCtftimeVerifiedAt()
		return nil
	case team.FieldLogo:
		m.ClearLogo()
		return nil
	case team.FieldVerifiedAt:
		m.ClearVerifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldDescription:
		m.ResetDescription()
		return nil
	case team.FieldCtftimeID:
		m.ResetCtftimeID()
		return nil
	case team.FieldCtftimeVerifiedAt:
		m.ResetCtftimeVerifiedAt()
		return nil
	case team.FieldLogo:
		m.ResetLogo()
		return nil
	case team.FieldVerifiedAt:
		m.ResetVerifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.captain != nil {
		edges = append(edges, team.EdgeCaptain)
	}
	if m.verified_by != nil {
		edges = append(edges, team.EdgeVerifiedBy)
	}
	if m.members != nil {
		edges = append(edges, team.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeCaptain:
		if id := m.captain; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeVerifiedBy:
		if id := m.verified_by; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmembers != nil {
		edges = append(edges, team.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcaptain {
		edges = append(edges, team.EdgeCaptain)
	}
	if m.clearedverified_by {
		edges = append(edges, team.EdgeVerifiedBy)
	}
	if m.clearedmembers {
		edges = append(edges, team.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeCaptain:
		return m.clearedcaptain
	case team.EdgeVerifiedBy:
		return m.clearedverified_by
	case team.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeCaptain:
		m.ClearCaptain()
		return nil
	case team.EdgeVerifiedBy:
		m.ClearVerifiedBy()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeCaptain:
		m.ResetCaptain()
		return nil
	case team.EdgeVerifiedBy:
		m.ResetVerifiedBy()
		return nil
	case team.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	username           *string
	email              *string
	email_confirmed_at *time.Time
	confirmation_code  *string
	permission_level   *user.PermissionLevel
	description        *string
	password           *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	teams              map[int]struct{}
	removedteams       map[int]struct{}
	clearedteams       bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetEmailConfirmedAt sets the "email_confirmed_at" field.
func (m *UserMutation) SetEmailConfirmedAt(t time.Time) {
	m.email_confirmed_at = &t
}

// EmailConfirmedAt returns the value of the "email_confirmed_at" field in the mutation.
func (m *UserMutation) EmailConfirmedAt() (r time.Time, exists bool) {
	v := m.email_confirmed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailConfirmedAt returns the old "email_confirmed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailConfirmedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailConfirmedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailConfirmedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailConfirmedAt: %w", err)
	}
	return oldValue.EmailConfirmedAt, nil
}

// ClearEmailConfirmedAt clears the value of the "email_confirmed_at" field.
func (m *UserMutation) ClearEmailConfirmedAt() {
	m.email_confirmed_at = nil
	m.clearedFields[user.FieldEmailConfirmedAt] = struct{}{}
}

// EmailConfirmedAtCleared returns if the "email_confirmed_at" field was cleared in this mutation.
func (m *UserMutation) EmailConfirmedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailConfirmedAt]
	return ok
}

// ResetEmailConfirmedAt resets all changes to the "email_confirmed_at" field.
func (m *UserMutation) ResetEmailConfirmedAt() {
	m.email_confirmed_at = nil
	delete(m.clearedFields, user.FieldEmailConfirmedAt)
}

// SetConfirmationCode sets the "confirmation_code" field.
func (m *UserMutation) SetConfirmationCode(s string) {
	m.confirmation_code = &s
}

// ConfirmationCode returns the value of the "confirmation_code" field in the mutation.
func (m *UserMutation) ConfirmationCode() (r string, exists bool) {
	v := m.confirmation_code
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmationCode returns the old "confirmation_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConfirmationCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmationCode: %w", err)
	}
	return oldValue.ConfirmationCode, nil
}

// ClearConfirmationCode clears the value of the "confirmation_code" field.
func (m *UserMutation) ClearConfirmationCode() {
	m.confirmation_code = nil
	m.clearedFields[user.FieldConfirmationCode] = struct{}{}
}

// ConfirmationCodeCleared returns if the "confirmation_code" field was cleared in this mutation.
func (m *UserMutation) ConfirmationCodeCleared() bool {
	_, ok := m.clearedFields[user.FieldConfirmationCode]
	return ok
}

// ResetConfirmationCode resets all changes to the "confirmation_code" field.
func (m *UserMutation) ResetConfirmationCode() {
	m.confirmation_code = nil
	delete(m.clearedFields, user.FieldConfirmationCode)
}

// SetPermissionLevel sets the "permission_level" field.
func (m *UserMutation) SetPermissionLevel(ul user.PermissionLevel) {
	m.permission_level = &ul
}

// PermissionLevel returns the value of the "permission_level" field in the mutation.
func (m *UserMutation) PermissionLevel() (r user.PermissionLevel, exists bool) {
	v := m.permission_level
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionLevel returns the old "permission_level" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPermissionLevel(ctx context.Context) (v user.PermissionLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionLevel: %w", err)
	}
	return oldValue.PermissionLevel, nil
}

// ResetPermissionLevel resets all changes to the "permission_level" field.
func (m *UserMutation) ResetPermissionLevel() {
	m.permission_level = nil
}

// SetDescription sets the "description" field.
func (m *UserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[user.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[user.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, user.FieldDescription)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *UserMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *UserMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *UserMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *UserMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *UserMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *UserMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *UserMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.email_confirmed_at != nil {
		fields = append(fields, user.FieldEmailConfirmedAt)
	}
	if m.confirmation_code != nil {
		fields = append(fields, user.FieldConfirmationCode)
	}
	if m.permission_level != nil {
		fields = append(fields, user.FieldPermissionLevel)
	}
	if m.description != nil {
		fields = append(fields, user.FieldDescription)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldEmailConfirmedAt:
		return m.EmailConfirmedAt()
	case user.FieldConfirmationCode:
		return m.ConfirmationCode()
	case user.FieldPermissionLevel:
		return m.PermissionLevel()
	case user.FieldDescription:
		return m.Description()
	case user.FieldPassword:
		return m.Password()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldEmailConfirmedAt:
		return m.OldEmailConfirmedAt(ctx)
	case user.FieldConfirmationCode:
		return m.OldConfirmationCode(ctx)
	case user.FieldPermissionLevel:
		return m.OldPermissionLevel(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldEmailConfirmedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailConfirmedAt(v)
		return nil
	case user.FieldConfirmationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmationCode(v)
		return nil
	case user.FieldPermissionLevel:
		v, ok := value.(user.PermissionLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionLevel(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmailConfirmedAt) {
		fields = append(fields, user.FieldEmailConfirmedAt)
	}
	if m.FieldCleared(user.FieldConfirmationCode) {
		fields = append(fields, user.FieldConfirmationCode)
	}
	if m.FieldCleared(user.FieldDescription) {
		fields = append(fields, user.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmailConfirmedAt:
		m.ClearEmailConfirmedAt()
		return nil
	case user.FieldConfirmationCode:
		m.ClearConfirmationCode()
		return nil
	case user.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldEmailConfirmedAt:
		m.ResetEmailConfirmedAt()
		return nil
	case user.FieldConfirmationCode:
		m.ResetConfirmationCode()
		return nil
	case user.FieldPermissionLevel:
		m.ResetPermissionLevel()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.teams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedteams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteams {
		edges = append(edges, user.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
